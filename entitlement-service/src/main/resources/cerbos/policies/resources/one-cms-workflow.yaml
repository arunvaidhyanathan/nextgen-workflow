# resources/one-cms-workflow.yaml  
# Hybrid Workflow Resource Policy for OneCMS workflow operations
# Version: 2.0 - BPMN-aware platform-level workflow policy with hybrid authorization
# This policy governs workflow, task, and queue operations enforced by Flowable Core Workflow Service
apiVersion: "api.cerbos.dev/v1"
resourcePolicy:
  # Namespaced resource identifier: BusinessApp::ProcessDefinitionKey
  resource: "OneCMS::oneCmsCaseWorkflow"
  version: "2.0"
  importDerivedRoles:
    - one_cms_derived_roles
  rules:
    # ========================================
    # WORKFLOW INSTANCE MANAGEMENT
    # ========================================
    - actions: ["start_workflow_instance", "initiate_process", "start_process"]
      effect: EFFECT_ALLOW
      roles:
        - "INTAKE_ANALYST"
        - "EO_INTAKE_ANALYST"
        - "GROUP_EO_INTAKE_ANALYST"
      derivedRoles:
        - intake_phase_authorized
        - database_authorized    # Hybrid mode: check database permissions
      condition:
        match:
          all:
            of:
              - expr: request.principal.attr.isActive == true
              # Hybrid mode: check database permission if available
              - expr: |
                  !has(request.principal.attr.databasePermissions) ||
                  "workflow:start" in request.principal.attr.databasePermissions

    - actions: ["terminate_workflow", "cancel_process", "suspend_process", "activate_process"]
      effect: EFFECT_ALLOW
      roles:
        - "INVESTIGATION_MANAGER"
        - "GROUP_INVESTIGATION_MANAGER"
        - "EO_OFFICER"
        - "GROUP_EO_OFFICER"
        - "EO_HEAD" 
        - "GROUP_EO_HEAD"
      derivedRoles:
        - cross_department_manager
        - queue_supervisor
      condition:
        match:
          expr: request.principal.attr.isActive == true

    # ========================================
    # QUEUE ACCESS MANAGEMENT
    # ========================================
    - actions: ["view_queue", "list_queue_tasks", "access_queue"]
      effect: EFFECT_ALLOW
      roles: ["user"] # All authenticated users can potentially view queues
      derivedRoles:
        - queue_member
        - database_authorized
      condition:
        match:
          all:
            of:
              - expr: request.principal.attr.isActive == true
              # Allow ONLY if the requested queue is in the principal's entitled queues
              # Entitlement Service builds principal.attr.queues from business_app_roles.metadata.queues
              - expr: |
                  has(request.resource.attr.currentQueue) &&
                  request.resource.attr.currentQueue in request.principal.attr.queues

    # ========================================
    # TASK VIEWING AND ACCESS
    # ========================================
    - actions: ["view_task", "read_task", "get_task_details"]
      effect: EFFECT_ALLOW
      roles: ["user"]
      derivedRoles:
        - queue_member
        - task_assignee
        - queue_supervisor
        - database_authorized
        - resource_level_authorized
      condition:
        match:
          all:
            of:
              - expr: request.principal.attr.isActive == true
              # Allow if user has access to the task's queue OR is the assignee
              - expr: |
                  (has(request.resource.attr.currentTask) &&
                   (request.resource.attr.currentTask.queue in request.principal.attr.queues ||
                    request.resource.attr.currentTask.assignee == request.principal.id)) ||
                  # Supervisors can view tasks in their supervised queues
                  (has(request.principal.attr.supervisedQueues) &&
                   request.resource.attr.currentTask.queue in request.principal.attr.supervisedQueues)

    # ========================================
    # TASK CLAIMING (BPMN Candidate Group Integration)
    # ========================================
    - actions: ["claim_task", "assign_to_self"]
      effect: EFFECT_ALLOW
      roles: ["user"]
      derivedRoles:
        - queue_member
        - database_authorized
      condition:
        match:
          all:
            of:
              - expr: request.principal.attr.isActive == true
              # Rule 1: User must have access to the queue the task is in
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.queue in request.principal.attr.queues
              # Rule 2: Task must be unassigned (null assignee) or claimable
              - expr: |
                  request.resource.attr.currentTask.assignee == null ||
                  request.resource.attr.currentTask.status == "OPEN"
              # Rule 3: Check BPMN candidate group alignment
              - expr: |
                  !has(request.resource.attr.currentTask.candidateGroups) ||
                  size(request.resource.attr.currentTask.candidateGroups.filter(group, 
                    has(request.principal.attr.roles[group]))) > 0

    # ========================================
    # TASK COMPLETION (BPMN Task Integration)
    # ========================================
    - actions: ["complete_task", "finish_task", "submit_task"]
      effect: EFFECT_ALLOW
      roles: ["user"]
      derivedRoles:
        - task_assignee
        - emergency_access_user
      condition:
        match:
          all:
            of:
              - expr: request.principal.attr.isActive == true
              # Allow ONLY if the principal is the current assignee of the task
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.assignee == request.principal.id
              # Additional check: task must be in CLAIMED status
              - expr: |
                  request.resource.attr.currentTask.status == "CLAIMED" ||
                  request.resource.attr.currentTask.status == "IN_PROGRESS"

    # ========================================
    # TASK DELEGATION AND REASSIGNMENT
    # ========================================
    - actions: ["delegate_task", "reassign_task", "transfer_task"]
      effect: EFFECT_ALLOW
      roles:
        - "INVESTIGATION_MANAGER"
        - "GROUP_INVESTIGATION_MANAGER"
        - "EO_OFFICER"
        - "GROUP_EO_OFFICER"
        - "EO_HEAD"
        - "GROUP_EO_HEAD"
        - "CSIS_INTAKE_MANAGER"
        - "GROUP_CSIS_INTAKE_MANAGER"
      derivedRoles:
        - queue_supervisor
        - task_assignee
      condition:
        match:
          any:
            of:
              # Manager can delegate any task in their queues
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.queue in request.principal.attr.queues &&
                  (has(request.principal.attr.roles.GROUP_INVESTIGATION_MANAGER) ||
                   has(request.principal.attr.roles.GROUP_EO_OFFICER) ||
                   has(request.principal.attr.roles.GROUP_CSIS_INTAKE_MANAGER))
              # Current assignee can delegate their own task
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.assignee == request.principal.id

    # ========================================
    # TASK UNCLAIMING/RELEASE
    # ========================================
    - actions: ["unclaim_task", "release_task"]
      effect: EFFECT_ALLOW
      roles: ["user"]
      derivedRoles:
        - task_assignee
        - queue_supervisor
      condition:
        match:
          any:
            of:
              # Current assignee can unclaim their task
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.assignee == request.principal.id
              # Supervisor can unclaim tasks in their queues
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.queue in request.principal.attr.queues &&
                  (has(request.principal.attr.roles.GROUP_INVESTIGATION_MANAGER) ||
                   has(request.principal.attr.roles.GROUP_EO_OFFICER))

    # ========================================
    # TASK HISTORY AND AUDIT
    # ========================================
    - actions: ["view_task_history", "view_audit_trail", "get_task_variables"]
      effect: EFFECT_ALLOW
      roles:
        - "INVESTIGATION_MANAGER"
        - "GROUP_INVESTIGATION_MANAGER"
        - "EO_OFFICER"
        - "GROUP_EO_OFFICER"
        - "EO_HEAD"
        - "GROUP_EO_HEAD"
        - "AROG_REVIEWER"
      derivedRoles:
        - audit_authorized
        - queue_supervisor
        - task_assignee
      condition:
        match:
          any:
            of:
              # Can view history of tasks in their entitled queues
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.queue in request.principal.attr.queues
              # Current assignee can view their task history
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.assignee == request.principal.id
              # Audit roles can view any task history
              - expr: |
                  has(request.principal.attr.roles.AROG_REVIEWER) ||
                  has(request.principal.attr.roles.GROUP_EO_OFFICER)

    # ========================================
    # PROCESS VARIABLE ACCESS
    # ========================================
    - actions: ["read_process_variables", "view_variables", "get_variables"]
      effect: EFFECT_ALLOW
      roles: ["user"]
      derivedRoles:
        - task_assignee
        - queue_member
        - queue_supervisor
      condition:
        match:
          any:
            of:
              # Can read variables if they have access to any queue in the process
              - expr: |
                  has(request.resource.attr.currentQueue) &&
                  request.resource.attr.currentQueue in request.principal.attr.queues
              # Current task assignee can read variables
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.assignee == request.principal.id

    - actions: ["update_process_variables", "set_variables", "modify_variables"]
      effect: EFFECT_ALLOW
      roles:
        - "INVESTIGATION_MANAGER"
        - "GROUP_INVESTIGATION_MANAGER"
        - "EO_OFFICER"
        - "GROUP_EO_OFFICER"
        - "EO_HEAD"
        - "GROUP_EO_HEAD"
      derivedRoles:
        - task_assignee
        - queue_supervisor
        - cross_department_manager

    # ========================================
    # ESCALATION AND NOTIFICATIONS
    # ========================================
    - actions: ["escalate_task", "send_notification", "create_notification"]
      effect: EFFECT_ALLOW
      roles:
        - "INVESTIGATION_MANAGER"
        - "GROUP_INVESTIGATION_MANAGER"
        - "EO_OFFICER"
        - "GROUP_EO_OFFICER"
        - "EO_HEAD"
        - "GROUP_EO_HEAD"
      derivedRoles:
        - task_assignee       # Assignee can escalate their own task
        - queue_supervisor
        - emergency_access_user
      condition:
        match:
          any:
            of:
              # Management roles can escalate
              - expr: |
                  has(request.principal.attr.roles.GROUP_INVESTIGATION_MANAGER) ||
                  has(request.principal.attr.roles.GROUP_EO_OFFICER)
              # Current assignee can escalate their task
              - expr: |
                  has(request.resource.attr.currentTask) &&
                  request.resource.attr.currentTask.assignee == request.principal.id
              # Emergency situations
              - expr: |
                  request.resource.attr.priority == "URGENT" ||
                  has(request.principal.attr.emergencyAccess)

    # ========================================
    # QUEUE MANAGEMENT (Supervisor Operations)
    # ========================================
    - actions: ["manage_queue", "rebalance_queue", "queue_statistics"]
      effect: EFFECT_ALLOW
      roles:
        - "INVESTIGATION_MANAGER"
        - "GROUP_INVESTIGATION_MANAGER"
        - "EO_OFFICER"
        - "GROUP_EO_OFFICER"
        - "CSIS_INTAKE_MANAGER"
        - "GROUP_CSIS_INTAKE_MANAGER"
      derivedRoles:
        - queue_supervisor
      condition:
        match:
          all:
            of:
              - expr: request.principal.attr.isActive == true
              - expr: |
                  has(request.resource.attr.currentQueue) &&
                  (request.resource.attr.currentQueue in request.principal.attr.queues ||
                   request.resource.attr.currentQueue in request.principal.attr.supervisedQueues)

    # ========================================
    # ADMINISTRATIVE WORKFLOW ACTIONS
    # ========================================
    - actions: ["audit", "export", "report", "delete", "admin_override"]
      effect: EFFECT_ALLOW
      roles:
        - "EO_OFFICER"
        - "GROUP_EO_OFFICER"
        - "EO_HEAD"
        - "GROUP_EO_HEAD"
        - "AROG_REVIEWER"
        - "INVESTIGATION_MANAGER"
        - "GROUP_INVESTIGATION_MANAGER"
        - "SYSTEM_ADMIN"
      derivedRoles:
        - audit_authorized
        - cross_department_manager
      condition:
        match:
          expr: request.principal.attr.isActive == true

    # ========================================
    # BUSINESS HOURS RESTRICTIONS
    # ========================================
    - actions: ["non_urgent_operations"]
      effect: EFFECT_ALLOW
      roles: ["user"]
      derivedRoles:
        - business_hours_user
        - emergency_access_user
      condition:
        match:
          any:
            of:
              # Normal business hours
              - expr: |
                  now().getHours() >= 8 && now().getHours() <= 18 &&
                  [1,2,3,4,5].exists(d, d == now().getDayOfWeek())
              # Emergency override
              - expr: |
                  request.resource.attr.priority == "URGENT" ||
                  has(request.principal.attr.emergencyAccess)

    # ========================================
    # GENERIC RESOURCE-LEVEL PERMISSIONS (ABAC Override)
    # ========================================
    - actions: ["*"]
      effect: EFFECT_ALLOW
      roles: ["user"]
      derivedRoles:
        - resource_level_authorized
      condition:
        match:
          all:
            of:
              - expr: request.principal.attr.isActive == true
              # Resource permission must exist for workflow operations
              - expr: |
                  has(request.principal.attr.resourcePermissions) &&
                  (has(request.principal.attr.resourcePermissions["workflow::" + request.resource.id]) ||
                   has(request.principal.attr.resourcePermissions["task::" + request.resource.attr.currentTask.id]) ||
                   has(request.principal.attr.resourcePermissions["queue::" + request.resource.attr.currentQueue]))
              # Check action is allowed
              - expr: |
                  (has(request.principal.attr.resourcePermissions["workflow::" + request.resource.id]) &&
                   request.action in request.principal.attr.resourcePermissions["workflow::" + request.resource.id].allowedActions) ||
                  (has(request.resource.attr.currentTask) &&
                   has(request.principal.attr.resourcePermissions["task::" + request.resource.attr.currentTask.id]) &&
                   request.action in request.principal.attr.resourcePermissions["task::" + request.resource.attr.currentTask.id].allowedActions) ||
                  (has(request.resource.attr.currentQueue) &&
                   has(request.principal.attr.resourcePermissions["queue::" + request.resource.attr.currentQueue]) &&
                   request.action in request.principal.attr.resourcePermissions["queue::" + request.resource.attr.currentQueue].allowedActions)

    # ========================================
    # NEXT AVAILABLE TASK (Queue Optimization)
    # ========================================
    - actions: ["get_next_task", "next_available_task"]
      effect: EFFECT_ALLOW
      roles: ["user"]
      derivedRoles:
        - queue_member
      condition:
        match:
          all:
            of:
              - expr: request.principal.attr.isActive == true
              - expr: |
                  has(request.resource.attr.currentQueue) &&
                  request.resource.attr.currentQueue in request.principal.attr.queues
              # Only during business hours for non-urgent queues
              - expr: |
                  request.resource.attr.priority == "URGENT" ||
                  has(request.principal.attr.emergencyAccess) ||
                  (now().getHours() >= 8 && now().getHours() <= 18)

  # ========================================
  # DEFAULT DENY RULE
  # ========================================
  defaultRule:
    effect: EFFECT_DENY